# 2026-01-18 (01)

## Session
- README の手順で `:load Basics.Syntax` まではできたが、その後の実行方法を確認した。
- `add :: Int -> Int -> Int` と `add a b = a + b` の役割を確認した。
- `Int -> Int -> Int` の分解と、TypeScript での対応表現を確認した。
- `factorial` の使い方と、0 のケースが停止条件になる理由を確認した。
- `sumList` のパターンマッチ `[]` と `(x:xs)` の意味を確認した。
- `sumList` と `factorial` の手動展開で評価の流れを確認した。
- `myLength` と `myReverse` を実装し、警告の扱いを確認した。
- リスト連結の `++` と `concat`、累積引数、型変数 `a`、`-Wtype-defaults` 警告を確認した。

## Notes
- GHCi ではロード後に式や関数名をそのまま入力して評価する。` :reload` で編集内容を反映できる。
- 型シグネチャは「型の宣言」、関数定義は「本体」を表す。
- `Int -> (Int -> Int)` と右結合で解釈され、引数を順に受け取って関数を返す（カリー化）。
- TypeScript では `(a: number) => (b: number) => number` の形で表せる。
- `factorial 0 = 1` は文法的必須ではないが、再帰を止めるための条件として論理的に必須。
- 停止条件は「パターンマッチで当たる」「そこで再帰を呼ばない」ことで読み取れる。
- `sumList [] = 0` は空リストの終端ケースで、ないとパターン不一致のエラーになる。
- `(x:xs)` はリストの「先頭」と「残り」を分解するパターンマッチで、`:` はコンストラクタ。
- リスト連結は `++`、リストのリストの連結は `concat` を使う。
- `a` は型変数で、どの型にも対応できることを表す。
- `-Wtype-defaults` は型が曖昧なため既定の型に決めたという警告で、型注釈で解消できる。
- `concat` を使った `myReverse` は書けるが、`++` と同様に効率は良くない。
- 累積引数は `go acc [] = acc` の形で途中結果を持ち回る。
- `sumList` と `factorial` の展開手順は以下の通り。

```haskell
sumList [1,2,3]
= sumList (1:2:3:[])
= 1 + sumList (2:3:[])
= 1 + (2 + sumList (3:[]))
= 1 + (2 + (3 + sumList []))
= 1 + (2 + (3 + 0))
= 6
```

```haskell
factorial 4
= 4 * factorial 3
= 4 * (3 * factorial 2)
= 4 * (3 * (2 * factorial 1))
= 4 * (3 * (2 * (1 * factorial 0)))
= 4 * (3 * (2 * (1 * 1)))
= 24
```

## Questions
- GHCi で `:load` 後に、実際の実行はどう行うのか？
- `add :: Int -> Int -> Int` が型宣言で、`add a b = a + b` が本体定義という理解で合っているか？
- `Int -> Int -> Int` の各 `Int` は何を表すのか？TypeScript ではどう書くのか？
- `factorial 0 = 1` が停止条件になっているのはなぜか？文法的に必須なのか？
- `sumList (x:xs)` の `:` や `x:xs` は何を意味するのか？
- 未使用変数警告（`-Wunused-matches`）はどう扱うのか？
- リストを連結する方法は何か？
- `concat` を使った `myReverse` の別解はあるか？
- 累積引数とは何か？
- 型シグネチャの `a` は何を意味するのか？
- GHCi の `-Wtype-defaults` 警告は何か？

---

# Exercises

## Exercise 1: myLength を実装する
- 問題: リストの長さを返す（Prelude の `length` を使わずに）
- 取り組み: パターンマッチで空リストとそれ以外を分ける。未使用変数は `_` にした。
- 結果: 警告なしで動作

```haskell
myLength :: [a] -> Int
myLength []     = 0
myLength (_:xs) = 1 + myLength xs
```

## Exercise 2: myReverse を実装する
- 問題: リストを逆順にする（Prelude の `reverse` を使わずに）
- 取り組み: `++` を使い、再帰で後ろに要素を追加
- 結果: 逆順のリストが得られる

```haskell
myReverse :: [a] -> [a]
myReverse [] = []
myReverse (x:xs) = myReverse xs ++ [x]
```
