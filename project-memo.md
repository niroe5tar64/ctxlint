# Context Spec 検証CLI（仮称：ctxlint）

## 概要

Context Spec 検証CLI（ctxlint）は、  
**人間・AIの両方が記述する「Context Spec（設計文書）」を構造的に検証し、  
曖昧・欠落・破綻した設計が次工程に進むことを防ぐためのCLIツール**である。

本ツールは「良い設計を自動生成する」ことを目的としない。  
**悪い・未完成な設計を確実に止めること**を唯一の責務とする。

---

## 背景・問題意識

AIを活用した開発（AI駆動開発／Context Engineering）が進むにつれ、  
以下の問題が顕在化している。

- Context Spec の粒度・構造が人やタイミングによって揺れる
- AIが「それっぽいが破綻したSpec」を生成する
- 設計レビューが感想戦・雰囲気判断になる
- 「どこまで決まっているか」「何が未決定か」が把握できない
- 結果として、人間の頭がボトルネックになる

これらは運用や注意力では解決できず、  
**構造として止める仕組み**が必要である。

---

## 目的

- Context Spec に最低限必要な構造・要素を定義する
- 未完成・危険な設計を **機械的に検出・拒否**する
- AIにSpecを書かせても「壊れない安全柵」を用意する
- 設計の判断基準を個人の暗黙知から切り離す

---

## このCLIが提供する価値

### 1. AIにSpecを書かせられるようになる

AIが生成したContext Specをそのまま信用しない。

```
AI生成Spec → ctxlint → OK / NG
```


という明確なゲートを設けることで、

- AIが設計を勝手に壊すことを防止
- 人間は「正しいか」ではなく「良いか」に集中できる
- AIをジュニア設計者として安全に扱える

---

### 2. 「曖昧な設計のまま進む」を物理的に防ぐ

以下のような状態を **明確なエラー** として検出する。

- 目的だけ書かれていて制約がない
- 判断基準が定義されていない
- 未決定事項が記録されていない
- 前提条件と結論が矛盾している

人の注意やレビュー文化に依存しない。

---

### 3. 設計思考を再利用可能な形で残せる

Context Spec の構造は、そのまま

- 何を先に決めるか
- 何が欠けると危険か
- どこで判断を止めるか

という **設計者の思考モデル**を表す。

CLIとして固定化することで、

- 他人に共有できる
- AIに理解させられる
- 将来の自分が再利用できる

---

## なぜ Haskell で作るのか

- Specを **状態遷移を持つ構造体**として表現できる
- 「未完成なSpec」と「完成したSpec」を型で分離できる
- 副作用（I/O）と検証ロジックを厳密に分離できる
- 「通ってはいけない設計」を型レベルで表現できる

例：

```haskell
data Spec
  = Incomplete IncompleteSpec
  | Complete CompleteSpec
```

完成状態でない限り、次工程に進めない設計が可能。

---

## 想定する最小スコープ（MVP）

## 入力
- Markdown形式の Context Spec

## 出力
- 成功：OK
- 失敗：エラー一覧（人間が修正可能な粒度）

## 最小検証項目（例）
- 必須セクションの存在チェック
- セクション間の依存関係チェック
- 明示的な「未決定事項」の有無
- 判断基準と結論の整合性

※ 内容の善し悪しは判断しない
※ 構造と完全性のみを検証対象とする

---

## 非目標（やらないこと）
- 良い設計かどうかの自動判定
- AIによる設計生成そのもの
- 実行計画やコード生成
- 曖昧さを許容する柔軟パーサ

---

## 将来的な拡張構想
- GitHub Actions での自動検証
- PRへの自動コメント
- diffベースでの意思決定履歴追跡
- AIによる Spec 自己修正 → 再検証ループ
- Spec を中心とした AI エージェントオーケストレーション

---

## このツールが作る世界観
- 設計が「雰囲気」から「構造」になる
- AIは自由に振る舞えないが、安心して使える
- 人間は判断と価値に集中できる
- 属人性は減り、設計力は再利用可能になる

---

## まとめ

Context Spec 検証CLIは、
- 設計を速くするツールではない。
- 設計を壊さないためのツールである。

AI時代において、
「何を作るか」よりも
「壊れない構造をどう作るか」を重視するための基盤である。


---

次セッションでは、このMarkdownを前提にして：

- 必須セクション定義
- Specの状態遷移
- エラー型設計
- CLI I/O設計

のどれから入るか決めよう。

📌 個人的おすすめは  
**「ダメなSpecのパターン列挙 → 型設計」**から。
